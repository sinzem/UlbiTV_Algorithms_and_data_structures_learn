const arr = [-7, -6, 0, 3, 2, 5, 6, 8, 1, 9, 4, 2, 1, 2, 9, 6, 4, 1, 7, -1, -5, 23, 6, 2, 35, 6, 3, 32, 40, 42];
let count = 0;

/* (Алгоритм быстрой сортировки - с помощью рекурсии) */
function quickSort(array) {
    if (array.length <= 1) { /* (база рекурсии - когда остается один элемент) */
        return array;
    }

    let pivotIndex = Math.floor(array.length / 2); /* (получаем средний индекс массива) */
    let pivot = array[pivotIndex]; /* (элемент по среднему индексу - желательно среднее число по величине, но искать среднее долго, поэтому сойдет любое наугад, принято брать среднее) */
    let less = []; /* (массив для чисел меньше среднего) */
    let greater = [];  /* (массив для чисел больше среднего) */
    for (let i = 0; i < array.length; i++) {
        count += 1; /* (счетчик операций) */
        if (i === pivotIndex) { /* (при переборе среднее число пропускаем) */
            continue;
        }
        /* (перебираем массив, сравниваем числа со средним, если число меньше, откидываем в массив less, остальные - в greater) */
        if (array[i] < pivot) { 
            less.push(array[i]);
        } else {
            greater.push(array[i]);
        }
    }
    return [...quickSort(less), pivot, ...quickSort(greater)]; /* (запускаем рекурсивно функцию с полученными подмассивами - будет перезапускаться, пока все подмассивы не сойдут к базе - одному элементу, потом все эти подмассивы каждый с одним элементом в обратном порядке из стека собираются в массив на выходе) */
}

console.log(quickSort(arr));
console.log("количество операций - " + count); /* (сложность - O(log2n * n), на данном массиве выдало 136 операций против 350 другими переборами, но так как операции сложные, по времени мы не выигрываем(на коротких массивах, но на больших ожидается значительно лучшие показатели по сравнению с другими методами)) */